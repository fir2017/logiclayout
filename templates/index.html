{% extends 'master.html' %}
{% block body %}

<p>
	Type in a <a href="http://en.wikipedia.org/wiki/Boolean_algebra">Boolean Alegbra</a> expression. Please use <code>&</code> for AND, <code>|</code> for OR, <code>~</code> for NOT, <code>^</code> for XOR.
</p>

<form action="/" method="POST" id="expression">
	<div class="input-group">
		<span class="input-group-addon">f=</span>
		<input type="text" class="form-control" name="logic-expression" placeholder="Logic expression">
	</div>
</form>

<!-- <canvas id="schematic" width="1280" height="600"></canvas> -->
<canvas id="canvas" resize></canvas>

<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.3.9/d3.min.js"></script>
<script type="text/javascript" src="/static/js/paper.js"></script>
<script src="/static/js/circuit.js"></script>
<!-- <script src="/static/js/logicgates.js"></script> -->

<script type="text/paperscript" canvas="canvas">
	
	// function drawAndGate(x, y, size, inputs) {

	// 	// determine height and length based on inputs
	// 	var h = size*inputs;
	// 	var l = h;
	// 	var midPoint = size/2; 

	// 	var gate = new Path({
	// 		strokeColor: 'black', 
	// 		strokeWidth: 2,
	// 	});

	// 	// creating the body of an AND gate
	// 	gate.moveTo(new Point(x - l/2, y - h/2));
	// 	gate.lineTo(new Point(x - l/2, y + h/2));
	// 	gate.lineTo(new Point(x, y + h/2));
	// 	gate.arcTo(new Point(x + l/2, y), new Point(x, y - h/2));
	// 	gate.closePath();

	// 	var andInputPoints = [];

	// 	// input pins
	// 	for (var i=0; i<inputs; i++) {
	// 		var from = new Point(x - l, y - h/2 + midPoint + i*size);
	// 		var to = new Point(x - l/2, y - h/2 + midPoint + i*size);
	// 		var pinLine = new Path.Line(from, to);
	// 		pinLine.strokeColor = 'black';
	// 		pinLine.strokeWidth = 2;
	// 		andInputPoints[i] = from;
	// 	}

	// 	// output pin
	// 	var gateOutput = new Point(x + l/2, y);
	// 	var outputPoint = new Point(x + l, y);
	// 	var pinLine = new Path.Line(gateOutput, outputPoint);
	// 	pinLine.strokeColor = 'black';
	// 	pinLine.strokeWidth = 2;

	// 	return andInputPoints;
	// }

	// function drawOrGate(x, y, size, inputs) {

	// 	// determine height and length based on inputs
	// 	var h = size*inputs;
	// 	var l = h;
	// 	var midPoint = size/2; 

	// 	var orInputPoints = [];

	// 	// input pins
	// 	for (var i=0; i<inputs; i++) {
	// 		var from = new Point(x - l, y - h/2 + midPoint + i*size);
	// 		var to = new Point(x - l/4, y - h/2 + midPoint + i*size);
	// 		var pinLine = new Path.Line(from, to);
	// 		pinLine.strokeColor = 'black';
	// 		pinLine.strokeWidth = 2;
	// 		orInputPoints[i] = from;
	// 	}

	// 	// creating the body of an AND gate
	// 	var gate = new Path({
	// 		strokeColor: 'black', 
	// 		strokeWidth: 2,
	// 		fillColor: 'white'
	// 	});
	// 	gate.moveTo(new Point(x - l/2, y - h/2));
	// 	gate.curveTo(new Point(x - l/4,y), new Point(x - l/2, y + h/2));
	// 	gate.quadraticCurveTo(new Point(x + l/4, y + h/2), new Point(x + l/2, y));
	// 	gate.quadraticCurveTo(new Point(x + l/4, y - h/2), new Point(x - l/2, y - h/2));

	// 	gate.closePath();

	// 	// output pin
	// 	var gateOutput = new Point(x + l/2, y);
	// 	var outputPoint = new Point(x + l, y);
	// 	var pinLine = new Path.Line(gateOutput, outputPoint);
	// 	pinLine.strokeColor = 'black';
	// 	pinLine.strokeWidth = 2;

	// 	return orInputPoints;
	// }

	// function drawXorGate(x, y, size, inputs) {

	// 	// determine height and length based on inputs
	// 	var h = size*inputs;
	// 	var l = h;
	// 	var offset = h/5;
	// 	var midPoint = size/2; 

	// 	var xorInputPoints = [];

	// 	// input pins
	// 	for (var i=0; i<inputs; i++) {
	// 		var from = new Point(x - l, y - h/2 + midPoint + i*size);
	// 		var to = new Point(x - l/4, y - h/2 + midPoint + i*size);
	// 		var pinLine = new Path.Line(from, to);
	// 		pinLine.strokeColor = 'black';
	// 		pinLine.strokeWidth = 2;
	// 		xorInputPoints[i] = from;
	// 	}

	// 	// creating the body of an AND gate
	// 	var gate = new Path({
	// 		strokeColor: 'black', 
	// 		strokeWidth: 2,
	// 		fillColor: 'white'
	// 	});
	// 	gate.moveTo(new Point(x - l/2, y - h/2));
	// 	gate.curveTo(new Point(x - l/4,y), new Point(x - l/2, y + h/2));
	// 	gate.quadraticCurveTo(new Point(x + l/4, y + h/2), new Point(x + l/2, y));
	// 	gate.quadraticCurveTo(new Point(x + l/4, y - h/2), new Point(x - l/2, y - h/2));

	// 	gate.closePath();

	// 	// xor line
	// 	var xorLine = new Path({
	// 		strokeColor: 'black', 
	// 		strokeWidth: 2
	// 	});
	// 	xorLine.moveTo(new Point(x - l/2 - offset, y - h/2));
	// 	xorLine.curveTo(new Point(x - l/4 - offset,y), new Point(x - l/2 - offset, y + h/2));
	

	// 	// output pin
	// 	var gateOutput = new Point(x + l/2, y);
	// 	var outputPoint = new Point(x + l*1.25, y);
	// 	var pinLine = new Path.Line(gateOutput, outputPoint);
	// 	pinLine.strokeColor = 'black';
	// 	pinLine.strokeWidth = 2;

	// 	return xorInputPoints;
	// }

	// function drawNotGate(x, y, size) {

	// 	// determine height and length based on inputs
	// 	var h = size;
	// 	var l = h;
	// 	var midPoint = size/2; 

	// 	var notInputPoints = [];

	// 	var from = new Point(x - l*1.5, y);
	// 	var to = new Point(x - l/2, y);
	// 	var inputLine = new Path.Line(from, to);
	// 	inputLine.strokeColor = 'black';
	// 	inputLine.strokeWidth = 2;
	// 	notInputPoints[0] = from;

	// 	// creating the body of an AND gate
	// 	var gate = new Path({
	// 		strokeColor: 'black', 
	// 		strokeWidth: 2,
	// 		fillColor: 'white'
	// 	});
	// 	gate.moveTo(new Point(x - l/2, y - h/2));
	// 	gate.lineTo(new Point(x - l/2, y + h/2));
	// 	gate.lineTo(new Point(x + l/2, y));
	// 	gate.closePath();

	// 	// output pin
	// 	var gateOutput = new Point(x + l/2, y);
	// 	var outputPoint = new Point(x + l*1.5, y);
	// 	var outputLine = new Path.Line(gateOutput, outputPoint);
	// 	outputLine.strokeColor = 'black';
	// 	outputLine.strokeWidth = 2;

	// 	// not circile of gate
	// 	var notCircle = new Path.Circle(new Point(x + l/2 + (size/6)/2,y), size/6);
	// 	notCircle.fillColor = 'white';	
	// 	notCircle.strokeColor = 'black';
	// 	notCircle.strokeWidth = 2;

	// 	return notInputPoints;
	// }


	// function drawInput(x, y, size, name, outputPoint) {

	// 	// determine height and length based on inputs
	// 	var h = size/2;
	// 	var l = size;

	// 	var pin = new Path({
	// 		strokeColor: 'black', 
	// 		strokeWidth: 2,
	// 	});

	// 	// creating the body of input
	// 	pin.moveTo(new Point(x - l/2, y + h/2));
	// 	pin.lineTo(new Point(x + l*0.75, y + h/2));
	// 	pin.lineTo(new Point(x + l, y));
	// 	pin.lineTo(new Point(x + l*0.75, y - h/2));
	// 	pin.lineTo(new Point(x - l/2, y - h/2));
	// 	pin.closePath();

	// 	// name of input
	// 	var text = new PointText(new Point(x - l*1.5, y + 4));
	// 	text.fillColor = 'black';
	// 	text.content = name;

	// 	// output pin
	// 	var rightOfPin = new Point(x + l, y);
	// 	var outputOfPin = new Point(x + l*1.5, y);
	// 	var pinLine = new Path.Line(rightOfPin, outputOfPin);
	// 	pinLine.strokeColor = 'black';
	// 	pinLine.strokeWidth = 2;

	// 	// connection line
	// 	var netConnection = new Path.Line(outputOfPin, outputPoint);
	// 	netConnection.strokeColor = 'black';
	// 	netConnection.strokeWidth = 2;

	// 	// // center of input
	// 	// var dot = new Path.Circle(new  Point(x, y), 3);
	// 	// dot.fillColor = 'red';

	// 	return [];
	// }

	// function drawOutput(x, y, size, name) {

	// 	// determine height and length based on inputs
	// 	var h = size/2;
	// 	var l = size;

	// 	var pin = new Path({
	// 		strokeColor: 'black', 
	// 		strokeWidth: 2,
	// 	});

	// 	// creating the body of input
	// 	pin.moveTo(new Point(x + l/2, y + h/2));
	// 	pin.lineTo(new Point(x - l*0.75, y + h/2));
	// 	pin.lineTo(new Point(x - l, y));
	// 	pin.lineTo(new Point(x - l*0.75, y - h/2));
	// 	pin.lineTo(new Point(x + l/2, y - h/2));
	// 	pin.closePath();

	// 	// name of input
	// 	var text = new PointText(new Point(x + l, y + 4));
	// 	text.fillColor = 'black';
	// 	text.content = name;

	// 	var inputPoints = [];

	// 	// output pin
	// 	var from = new Point(x - l*1.5, y);
	// 	var to = new Point(x - l, y);
		
	// 	var pinLine = new Path.Line(from, to);
	// 	pinLine.strokeColor = 'black';
	// 	pinLine.strokeWidth = 2;
	// 	inputPoints[0] = from;

	// 	return inputPoints;
	// }



	function drawCircuit() {
		var nets = drawAndGate(300,100,20,2);

		// for (var i=0; i<nets.length; i++){
		// 	drawInput(200, 75+75*i, 20, 'A', nets[i]);
		// }

		// drawAndGate(500, 100, 20, 2);
		// drawInput(400, 100, 20, 'A');
		// drawOrGate(500, 200, 20, 2);
		// drawXorGate(400, 200, 20, 2);
		// drawNotGate(300, 200, 20);
		// drawOutput(100,100,20, 'F');
	}


	drawCircuit();

	// var xWin = View.size.x;
	// console.log(xWin); 
	// var windowSpace = Rectangle(0,0,view.bounds);

	// var path = new Path.Circle(view.bounds.center, 30);
	// path.fillColor = 'red';
	console.log(view.bounds.width);

	// function onResize(event) {
	// 	// Whenever the view is resized, move the path to its center:
	// 	// var windowSpace = Rectange(view);
	// 	// var xWin = view.bounds.width;
	// 	// console.log(windowSpace.x);
	// 	// console.log(view.bounds.width);
	// }


</script>
<!--- 
<script type="text/javascript">

	// $("#expression").submit(function(ev){
	// 	ev.preventDefault(); // <-- go read up what this line does too
	// 	//ajax code goes here
	// 	// this replaces the usual POST and refresh
		
	// })

	// $(function(ev) {
	// 	// ev.preventDefault();
	// 	// e.g. number of inputs to destination rendering space
	// 	var someScale = d3.scale.linear().domain([0, 4]).range([0, 400]);
	// 	draw(100,100, 1);
	// 	return false;
	// })
</script>
-->

{% endblock %}
